// src/services/api.ts
import axios, {
  AxiosError,
  AxiosResponse,
  InternalAxiosRequestConfig,
} from 'axios';

// ————————————————————————————————————————
// Tell Axios how to handle Rails' CSRF cookie
// ————————————————————————————————————————
axios.defaults.xsrfCookieName = 'CSRF-TOKEN';
axios.defaults.xsrfHeaderName = 'X-CSRF-Token';
axios.defaults.withCredentials  = true;

const baseUrl = import.meta.env.VITE_API_BASE_URL || 'https://localhost:3001';

let isRefreshing = false;
let failedQueue: {
  resolve: (value: any) => void;
  reject:  (reason?: any) => void;
}[] = [];

// ————————————————————————————————————————
// Create our Axios instance
// ————————————————————————————————————————
const axiosInstance = axios.create({
  baseURL: baseUrl,
  headers: { 'Content-Type': 'application/json' },
  withCredentials: true,
});

// ————————————————————————————————————————
// Helpers for JWT refresh queue
// ————————————————————————————————————————
const processQueue = (error: AxiosError | null, token: string | null = null) => {
  failedQueue.forEach(p => {
    error ? p.reject(error) : p.resolve(token);
  });
  failedQueue = [];
};

const refreshToken = () => axiosInstance.post('/api/v1/refresh_token');

// ————————————————————————————————————————
// Response interceptor: catch 401, refresh JWT, retry
// ————————————————————————————————————————
axiosInstance.interceptors.response.use(
  (response: AxiosResponse) => response,

  async (error: AxiosError) => {
    const originalRequest = error.config as InternalAxiosRequestConfig & { _retry?: boolean };

    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        // queue up until refresh completes
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        })
          .then(token => {
            originalRequest.headers = originalRequest.headers || {};
            originalRequest.headers['Authorization'] = `Bearer ${token}`;
            return axiosInstance(originalRequest);
          })
          .catch(err => Promise.reject(err));
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        const { data } = await refreshToken();
        const newToken = data.token;
        // set the new JWT for future requests
        axiosInstance.defaults.headers['Authorization'] = `Bearer ${newToken}`;
        processQueue(null, newToken);
        // retry original request
        originalRequest.headers = originalRequest.headers || {};
        originalRequest.headers['Authorization'] = `Bearer ${newToken}`;
        return axiosInstance(originalRequest);
      } catch (err) {
        processQueue(err as AxiosError, null);
        return Promise.reject(err);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);

// ————————————————————————————————————————
// Convenience methods
// ————————————————————————————————————————
const request = async (
  method: InternalAxiosRequestConfig['method'],
  url: string,
  data?: any
) => {
  const response = await axiosInstance.request({ method, url, data });
  return response.data;
};

export const get  = (url: string)     => request('get',    url);
export const post = (url: string, body: any) => request('post',   url, body);
export const put  = (url: string, body: any) => request('put',    url, body);
export const del  = (url: string)     => request('delete', url);
export const logout = () => request('delete', '/api/v1/logout');

export default axiosInstance;
